<!DOCTYPE html>

<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Agar Mobile</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Arial,sans-serif}
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    #gameContainer{position:relative;width:100vw;height:100vh;background:linear-gradient(45deg,#001122 0%,#003344 100%)}
    #gameCanvas{display:block;width:100%;height:100%;touch-action:none;cursor:none}
    .hidden{display:none!important}

/* HUD - Glassmorphism */
#ui{
position:absolute;left:10px;top:10px;z-index:10;color:#fff;
background:rgba(255,255,255,0.1);
backdrop-filter:blur(20px);
-webkit-backdrop-filter:blur(20px);
border:1px solid rgba(255,255,255,0.2);
border-radius:16px;
padding:12px 16px;
box-shadow:0 8px 32px rgba(0,0,0,0.3);
font-weight:600;
text-shadow:none;
}

/* Start - Glassmorphism */
#start{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20}
#start .box{
width:min(420px,92vw);
background:rgba(255,255,255,0.1);
backdrop-filter:blur(30px);
-webkit-backdrop-filter:blur(30px);
border:1px solid rgba(0,255,153,0.3);
color:#fff;
border-radius:20px;
padding:24px;
text-align:center;
box-shadow:0 16px 40px rgba(0,0,0,0.4);
}
#start h1{margin:8px 0 12px 0;text-shadow:0 2px 10px rgba(0,0,0,0.5)}
#start p{opacity:0.9;margin-bottom:20px}
#start button{
width:100%;padding:16px;border-radius:12px;border:none;
background:rgba(0,255,136,0.9);
backdrop-filter:blur(10px);
-webkit-backdrop-filter:blur(10px);
font-weight:800;font-size:18px;
box-shadow:0 4px 20px rgba(0,255,136,0.3);
transition:all 0.3s ease;
cursor:pointer;
}
#start button:hover{
background:rgba(0,255,136,1);
transform:translateY(-2px);
box-shadow:0 6px 25px rgba(0,255,136,0.4);
}

/* Game over - Glassmorphism */
#over{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20}
#over .box{
width:min(420px,92vw);
background:rgba(255,255,255,0.1);
backdrop-filter:blur(30px);
-webkit-backdrop-filter:blur(30px);
border:1px solid rgba(255,102,102,0.3);
color:#fff;
border-radius:20px;
padding:20px;
text-align:center;
box-shadow:0 16px 40px rgba(0,0,0,0.4);
}
#over h2{text-shadow:0 2px 10px rgba(0,0,0,0.5);margin-bottom:12px}
#over button{
padding:12px 20px;border-radius:12px;border:none;
background:rgba(0,255,136,0.9);
backdrop-filter:blur(10px);
-webkit-backdrop-filter:blur(10px);
font-weight:800;
box-shadow:0 4px 20px rgba(0,255,136,0.3);
transition:all 0.3s ease;
cursor:pointer;
}
#over button:hover{
background:rgba(0,255,136,1);
transform:translateY(-2px);
}

/* Minimap - Glassmorphism */
#minimapWrap{
position:absolute;right:10px;top:10px;z-index:12;
background:rgba(255,255,255,0.1);
backdrop-filter:blur(20px);
-webkit-backdrop-filter:blur(20px);
border:1px solid rgba(0,255,170,0.3);
border-radius:16px;
padding:8px;
box-shadow:0 8px 32px rgba(0,0,0,0.3);
}
#minimap{display:block;width:180px;height:130px;border-radius:10px}

/* Status do Rage Mode */
#rageStatus{
position:absolute;left:10px;bottom:10px;z-index:10;
background:rgba(255,0,110,0.2);
backdrop-filter:blur(15px);
-webkit-backdrop-filter:blur(15px);
border:1px solid rgba(255,0,110,0.4);
border-radius:12px;
padding:8px 12px;
color:#fff;
font-size:14px;
font-weight:600;
box-shadow:0 4px 16px rgba(255,0,110,0.3);
display:none;
}

  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui" class="hidden">Pontua√ß√£o: <b id="score">0</b> ‚Ä¢ Massa: <b id="mass">10</b></div>
    <div id="rageStatus">üò° RAGE MODE (<span id="rageTime">10</span>s)</div>
    <div id="start">
      <div class="box">
        <h1>ü¶† Agar Mobile</h1>
        <p>Toque para andar ‚Ä¢ Duplo-toque/Espa√ßo: dividir ‚Ä¢ W: ejetar massa</p>
        <p style="font-size:14px;opacity:0.8">üò° Colete b√¥nus RAGE MODE para crescer 3x mais r√°pido!</p>
        <p style="font-size:12px;opacity:0.7">ü§ñ 6 TIPOS DE INIMIGOS: B√°sico, Agressivo, Cauteloso, Veloz, Tanque, Ca√ßador!</p>
        <p style="font-size:12px;opacity:0.6">Teste: Tecla R = Rage Mode instant√¢neo</p>
        <button id="btnStart">COME√áAR</button>
      </div>
    </div>
    <div id="over" class="hidden">
      <div class="box">
        <h2>üíÄ Game Over</h2>
        <p>Pontua√ß√£o: <b id="finalScore">0</b> ‚Ä¢ Massa: <b id="finalMass">0</b></p>
        <button id="btnRestart">Jogar novamente</button>
      </div>
    </div>
    <div id="minimapWrap" class="hidden"><canvas id="minimap" width="180" height="130"></canvas></div>
  </div>

<script>
// ===== Evita rolagem no iOS/Android durante o jogo =====
document.addEventListener('touchmove', (e)=>{ if (window.__GAME_RUNNING__) e.preventDefault(); }, {passive:false});

// ===== Setup b√°sico =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');
const ui = document.getElementById('ui');
const startPane = document.getElementById('start');
const overPane = document.getElementById('over');
const minimapWrap = document.getElementById('minimapWrap');

let W = innerWidth, H = innerHeight, DPR = Math.max(1, Math.floor(devicePixelRatio||1));
function fit(){ W = innerWidth; H = innerHeight; DPR=Math.max(1,Math.floor(devicePixelRatio||1)); canvas.width=W*DPR; canvas.height=H*DPR; ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize', fit, {passive:true}); fit();

// ===== Mundo =====
const WORLD_W = 2400, WORLD_H = 1800;
const FRUITS = ['üçé','üçå','üçá','üçì','üçä'];
let gameRunning=false, score=0;
let player, enemies=[], food=[], powerUps=[], viruses=[], pellets=[], particles=[];
let camera={x:WORLD_W/2,y:WORLD_H/2,zoom:1};
let mouse={x:WORLD_W/2,y:WORLD_H/2};
let moveTarget=null, startTime=0, splitEnd=0;
const INITIAL_MASS=12;

function massToRadius(m){ return Math.sqrt(Math.max(0.0001,m))*2+5; }

function spawnEnemy(){
  const types = ['basic', 'aggressive', 'cautious', 'speedy', 'tank', 'hunter'];
  const type = types[Math.floor(Math.random() * types.length)];
  
  let enemy = {
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    mass: 20+Math.random()*50,
    radius: 0,
    vx: 0, vy: 0,
    behavior: 'wander',
    target: null,
    fearLevel: 0,
    lastThink: 0,
    type: type,
    blinkTimer: Math.random() * 1000,
    animPhase: Math.random() * 6.28
  };
  
  // Configurar atributos baseados no tipo
  switch(type) {
    case 'basic':
      enemy.color = `hsl(${200 + Math.random()*60}, 60%, 50%)`;
      enemy.baseSpeed = 0.3;
      enemy.aggressiveness = 0.3;
      break;
      
    case 'aggressive':
      enemy.color = `hsl(${0 + Math.random()*30}, 70%, 50%)`;
      enemy.mass = 30 + Math.random()*40; // Maior
      enemy.baseSpeed = 0.4;
      enemy.aggressiveness = 0.8;
      break;
      
    case 'cautious':
      enemy.color = `hsl(${180 + Math.random()*40}, 55%, 60%)`;
      enemy.mass = 15 + Math.random()*25; // Menor
      enemy.baseSpeed = 0.25;
      enemy.aggressiveness = 0.1;
      break;
      
    case 'speedy':
      enemy.color = `hsl(${60 + Math.random()*40}, 65%, 55%)`;
      enemy.mass = 10 + Math.random()*20; // Bem pequeno
      enemy.baseSpeed = 0.6;
      enemy.aggressiveness = 0.4;
      break;
      
    case 'tank':
      enemy.color = `hsl(${280 + Math.random()*40}, 50%, 45%)`;
      enemy.mass = 50 + Math.random()*60; // Bem grande
      enemy.baseSpeed = 0.15;
      enemy.aggressiveness = 0.2;
      break;
      
    case 'hunter':
      enemy.color = `hsl(${120 + Math.random()*40}, 70%, 45%)`;
      enemy.mass = 25 + Math.random()*35;
      enemy.baseSpeed = 0.35;
      enemy.aggressiveness = 0.6;
      break;
  }
  
  enemy.radius = massToRadius(enemy.mass);
  enemies.push(enemy);
}

function reset(){
  player={x:WORLD_W/2,y:WORLD_H/2,mass:INITIAL_MASS,radius:massToRadius(INITIAL_MASS),vx:0,vy:0,split:false,splitBalls:[],
    // Rage Mode
    rageMode:false, rageEnd:0
  };
  enemies=[]; food=[]; powerUps=[]; viruses=[]; pellets=[]; particles=[];
  for(let i=0;i<320;i++){food.push(randFruit());}
  // Spawnar inimigos com diferentes tipos
  for(let i=0;i<25;i++){spawnEnemy();}
  // Spawnar alguns b√¥nus Rage Mode
  for(let i=0;i<5;i++){spawnRageBonus();}
  for(let i=0;i<12;i++){viruses.push({x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,radius:18+Math.random()*8,rotation:0,pulse:Math.random()*6.28});}
}

function spawnRageBonus(){
  powerUps.push({
    x: Math.random()*WORLD_W,
    y: Math.random()*WORLD_H,
    radius: 15,
    type: 'rage',
    color: '#FF006E',
    emoji: 'üò°',
    pulse: Math.random()*6.28
  });
}

function createParticles(x, y, color = '#FFD700'){
  for(let i=0; i<6; i++){
    particles.push({
      x: x + (Math.random()-0.5)*10,
      y: y + (Math.random()-0.5)*10,
      vx: (Math.random()-0.5)*4,
      vy: (Math.random()-0.5)*4,
      life: Date.now() + 800,
      color: color,
      size: Math.random()*3+1
    });
  }
}

function randFruit(){ const e=FRUITS[Math.floor(Math.random()*FRUITS.length)]; return {x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,radius:10,emoji:e}; }

function updateEnemyAI(enemy, now){
  // Pensar a cada 200ms para economia de performance
  if(now - enemy.lastThink < 200) return;
  enemy.lastThink = now;
  
  // Calcular posi√ß√£o e massa do player
  const pX = player.split ? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
  const pY = player.split ? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
  const pMass = player.split ? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass;
  const distToPlayer = Math.hypot(enemy.x - pX, enemy.y - pY);
  
  // Reduzir medo gradualmente
  enemy.fearLevel = Math.max(0, enemy.fearLevel - 1);
  
  // Decidir comportamento baseado na situa√ß√£o
  if(distToPlayer < 200){
    if(player.rageMode){
      // Muito medo do rage mode
      enemy.behavior = 'flee';
      enemy.target = {x: pX, y: pY};
      enemy.fearLevel = 10;
    } else if(enemy.mass > pMass * 1.3){
      // Sou maior, vou perseguir
      enemy.behavior = 'chase';
      enemy.target = {x: pX, y: pY};
    } else if(pMass > enemy.mass * 1.3){
      // Player √© maior, fugir!
      enemy.behavior = 'flee';
      enemy.target = {x: pX, y: pY};
      enemy.fearLevel = 5;
    } else {
      // Tamanhos similares, procurar comida
      enemy.behavior = 'hunt_food';
    }
  } else {
    // Longe do player, procurar comida ou vagar
    if(Math.random() < 0.3){
      enemy.behavior = 'hunt_food';
    } else {
      enemy.behavior = 'wander';
    }
  }
  
  // Encontrar comida pr√≥xima se estiver procurando
  if(enemy.behavior === 'hunt_food'){
    let closestFood = null;
    let closestDist = Infinity;
    
    for(const f of food){
      const dist = Math.hypot(enemy.x - f.x, enemy.y - f.y);
      if(dist < 150 && dist < closestDist){
        closestFood = f;
        closestDist = dist;
      }
    }
    
    if(closestFood){
      enemy.target = {x: closestFood.x, y: closestFood.y};
    } else {
      enemy.behavior = 'wander';
    }
  }
}

function moveEnemyAI(enemy){
  let targetX = enemy.x, targetY = enemy.y;
  let speed = enemy.baseSpeed || 0.3; // Usar velocidade base do tipo
  
  // Ajustar velocidade baseado no tamanho
  speed = speed * (30 / (enemy.radius + 10));
  
  // Modificadores baseados no tipo
  if(enemy.type === 'aggressive' && enemy.behavior === 'chase') {
    speed *= 1.4; // Agressivos s√£o mais r√°pidos quando perseguindo
  } else if(enemy.type === 'cautious' && enemy.behavior === 'flee') {
    speed *= 1.6; // Cautelosos fogem mais r√°pido
  } else if(enemy.type === 'speedy') {
    speed *= 1.8; // Speedys s√£o sempre mais r√°pidos
  } else if(enemy.type === 'tank') {
    speed *= 0.6; // Tanks s√£o mais lentos
  }
  
  // Comportamentos
  switch(enemy.behavior){
    case 'chase':
      if(enemy.target){
        targetX = enemy.target.x;
        targetY = enemy.target.y;
        speed *= 1.2; // Mais r√°pido quando perseguindo
      }
      break;
      
    case 'flee':
      if(enemy.target){
        // Fugir na dire√ß√£o oposta
        const dx = enemy.x - enemy.target.x;
        const dy = enemy.y - enemy.target.y;
        const dist = Math.hypot(dx, dy) || 1;
        targetX = enemy.x + (dx/dist) * 100;
        targetY = enemy.y + (dy/dist) * 100;
        speed *= (1.5 + enemy.fearLevel * 0.1); // Mais r√°pido quando com medo
      }
      break;
      
    case 'hunt_food':
      if(enemy.target){
        targetX = enemy.target.x;
        targetY = enemy.target.y;
        speed *= 0.8; // Mais devagar quando procurando comida
      }
      break;
      
    case 'wander':
    default:
      // Movimento aleat√≥rio suave
      targetX = enemy.x + (Math.random() - 0.5) * 50;
      targetY = enemy.y + (Math.random() - 0.5) * 50;
      speed *= 0.6;
      break;
  }
  
  // Evitar bordas do mundo
  const margin = enemy.radius + 50;
  if(enemy.x < margin) targetX = enemy.x + 100;
  if(enemy.x > WORLD_W - margin) targetX = enemy.x - 100;
  if(enemy.y < margin) targetY = enemy.y + 100;
  if(enemy.y > WORLD_H - margin) targetY = enemy.y - 100;
  
  // Aplicar movimento suave
  const dx = targetX - enemy.x;
  const dy = targetY - enemy.y;
  const dist = Math.hypot(dx, dy) || 1;
  
  const ax = (dx / dist) * speed;
  const ay = (dy / dist) * speed;
  
  // Movimento com in√©rcia
  enemy.vx = enemy.vx * 0.8 + ax * 0.2;
  enemy.vy = enemy.vy * 0.8 + ay * 0.2;
  
  // Limitar velocidade m√°xima
  const maxSpeed = speed;
  const currentSpeed = Math.hypot(enemy.vx, enemy.vy);
  if(currentSpeed > maxSpeed){
    enemy.vx = (enemy.vx / currentSpeed) * maxSpeed;
    enemy.vy = (enemy.vy / currentSpeed) * maxSpeed;
  }
}

// ===== Controles =====
document.getElementById('btnStart').onclick = startGame;
document.getElementById('btnRestart').onclick = startGame;

canvas.addEventListener('mousemove', (e)=>{ if(!gameRunning) return; const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(W/r.width); const y=(e.clientY-r.top)*(H/r.height); const cx=W*0.5, cy=H*0.5; mouse.x=((x-cx)/camera.zoom)+camera.x; mouse.y=((y-cy)/camera.zoom)+camera.y; moveTarget=null; });
let lastTap=0;
canvas.addEventListener('touchstart', (e)=>{
  if(!gameRunning) return;
  const now=Date.now();
  if(now-lastTap<250){ splitPlayer(); }
  lastTap=now;
  const t=e.touches[0]; const r=canvas.getBoundingClientRect();
  const x=(t.clientX-r.left)*(W/r.width); const y=(t.clientY-r.top)*(H/r.height);
  const cx=W*0.5, cy=H*0.5; const wx=((x-cx)/camera.zoom)+camera.x, wy=((y-cy)/camera.zoom)+camera.y;
  moveTarget={x:wx,y:wy};
},{passive:false});
canvas.addEventListener('touchmove', (e)=>{
  if(!gameRunning) return;
  const t=e.touches[0]; const r=canvas.getBoundingClientRect();
  const x=(t.clientX-r.left)*(W/r.width); const y=(t.clientY-r.top)*(H/r.height);
  const cx=W*0.5, cy=H*0.5; const wx=((x-cx)/camera.zoom)+camera.x, wy=((y-cy)/camera.zoom)+camera.y;
  moveTarget={x:wx,y:wy};
},{passive:false});

document.addEventListener('keydown',(e)=>{
  if(!gameRunning) return;
  if(e.key===' '){ e.preventDefault(); splitPlayer(); }
  if(e.key.toLowerCase()==='w'){ e.preventDefault(); ejectMass(); }
  if(e.key.toLowerCase()==='r'){ 
    e.preventDefault(); 
    // Ativar Rage Mode para teste
    player.rageMode = true;
    player.rageEnd = Date.now() + 10000;
    const px = player.split ? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
    const py = player.split ? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
    for(let i=0; i<8; i++){
      createParticles(px + (Math.random()-0.5)*30, py + (Math.random()-0.5)*30, '#FF006E');
    }
  }
});

// ===== Jogo =====
function startGame(){
  reset();
  gameRunning=true; window.__GAME_RUNNING__=true;
  startTime=Date.now(); score=0; splitEnd=0; moveTarget=null;
  startPane.classList.add('hidden'); overPane.classList.add('hidden');
  ui.classList.remove('hidden'); minimapWrap.classList.remove('hidden');
  requestAnimationFrame(loop);
}
function endGame(){
  gameRunning=false; window.__GAME_RUNNING__=false;
  ui.classList.add('hidden'); minimapWrap.classList.add('hidden');
  document.getElementById('finalScore').textContent=score;
  document.getElementById('finalMass').textContent=Math.floor(player.mass);
  overPane.classList.remove('hidden');
}

function speedFromRadius(r){ return 6/Math.sqrt(r+40); }
function getTarget(){ return moveTarget?{x:moveTarget.x,y:moveTarget.y}:{x:mouse.x,y:mouse.y}; }

function movePlayer(){
  const t=getTarget();
  if(player.split && player.splitBalls.length){
    for(const b of player.splitBalls){
      const dx=t.x-b.x, dy=t.y-b.y, d=Math.hypot(dx,dy)||1;
      const ax=(dx/d)*0.35, ay=(dy/d)*0.35, maxS=speedFromRadius(b.radius);
      b.vx=(b.vx||0)*0.9+ax; b.vy=(b.vy||0)*0.9+ay;
      const v=Math.hypot(b.vx,b.vy); if(v>maxS){ b.vx=(b.vx/v)*maxS; b.vy=(b.vy/v)*maxS; }
      b.x+=b.vx; b.y+=b.vy; b.x=Math.max(b.radius,Math.min(WORLD_W-b.radius,b.x)); b.y=Math.max(b.radius,Math.min(WORLD_H-b.radius,b.y));
    }
  }else{
    const dx=t.x-player.x, dy=t.y-player.y, d=Math.hypot(dx,dy)||1;
    const ax=(dx/d)*0.35, ay=(dy/d)*0.35, maxS=speedFromRadius(player.radius);
    player.vx=(player.vx||0)*0.9+ax; player.vy=(player.vy||0)*0.9+ay;
    const v=Math.hypot(player.vx,player.vy); if(v>maxS){ player.vx=(player.vx/v)*maxS; player.vy=(player.vy/v)*maxS; }
    player.x+=player.vx; player.y+=player.vy; player.x=Math.max(player.radius,Math.min(WORLD_W-player.radius,player.x)); player.y=Math.max(player.radius,Math.min(WORLD_H-player.radius,player.y));
  }
}

function splitPlayer(){
  if(player.split || player.mass<20) return;
  const t=getTarget(); const a=Math.atan2(t.y-player.y,t.x-player.x), d=30, m=player.mass/2;
  player.split=true;
  player.splitBalls=[
    {x:player.x+Math.cos(a)*d,y:player.y+Math.sin(a)*d,mass:m,radius:massToRadius(m),vx:Math.cos(a)*3,vy:Math.sin(a)*3},
    {x:player.x-Math.cos(a)*d,y:player.y-Math.sin(a)*d,mass:m,radius:massToRadius(m),vx:-Math.cos(a)*3,vy:-Math.sin(a)*3}
  ];
  splitEnd = Date.now()+12000;
}

function ejectMass(){
  if(player.mass < 15) return;
  const t=getTarget();
  
  if(player.split){
    for(const b of player.splitBalls){
      if(b.mass < 15) continue;
      const a=Math.atan2(t.y-b.y,t.x-b.x);
      const ejectAmount = 2;
      const speed = 8;
      
      pellets.push({
        x: b.x + Math.cos(a) * (b.radius + 5),
        y: b.y + Math.sin(a) * (b.radius + 5),
        vx: Math.cos(a) * speed,
        vy: Math.sin(a) * speed,
        mass: ejectAmount,
        radius: 4,
        life: Date.now() + 5000
      });
      
      b.mass -= ejectAmount;
      b.radius = massToRadius(b.mass);
    }
  } else {
    const a=Math.atan2(t.y-player.y,t.x-player.x);
    const ejectAmount = 2;
    const speed = 8;
    
    pellets.push({
      x: player.x + Math.cos(a) * (player.radius + 5),
      y: player.y + Math.sin(a) * (player.radius + 5),
      vx: Math.cos(a) * speed,
      vy: Math.sin(a) * speed,
      mass: ejectAmount,
      radius: 4,
      life: Date.now() + 5000
    });
    
    player.mass -= ejectAmount;
    player.radius = massToRadius(player.mass);
  }
}

function maybeMerge(){
  if(!player.split) return;
  if(Date.now()>=splitEnd){
    const a=player.splitBalls[0], b=player.splitBalls[1];
    if(Math.hypot(a.x-b.x,a.y-b.y) < (a.radius+b.radius)*0.9){
      const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2; const total=a.mass+b.mass;
      player.split=false; player.x=cx; player.y=cy; player.mass=total; player.radius=massToRadius(total); player.splitBalls=[]; player.vx=0; player.vy=0;
    }
  }
}

function renderEnemy(e) {
  const time = Date.now() * 0.003;
  e.animPhase += 0.02;
  
  // Cor baseada no comportamento
  let displayColor = e.color;
  if(e.behavior === 'chase') displayColor = '#FF6B6B';
  else if(e.behavior === 'flee') displayColor = '#4ECDC4';
  else if(e.behavior === 'hunt_food') displayColor = '#45B7D1';
  else if(e.fearLevel > 0) displayColor = '#FFD93D';
  
  // Renderiza√ß√£o espec√≠fica por tipo
  switch(e.type) {
    case 'basic':
      // Inimigo padr√£o simples
      ctx.fillStyle = displayColor;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.45)';
      ctx.lineWidth = 1;
      ctx.stroke();
      break;
      
    case 'aggressive':
      // Inimigo com spikes
      const spikes = 8;
      const spikeLength = e.radius * 0.3;
      
      ctx.fillStyle = displayColor;
      ctx.beginPath();
      for(let i = 0; i < spikes; i++) {
        const angle = (i / spikes) * Math.PI * 2 + e.animPhase * 0.5;
        const innerR = e.radius - spikeLength * 0.5;
        const outerR = e.radius + spikeLength * (0.5 + Math.sin(time * 2 + i) * 0.3);
        
        if(i === 0) {
          ctx.moveTo(e.x + Math.cos(angle) * outerR, e.y + Math.sin(angle) * outerR);
        }
        
        const nextAngle = ((i + 1) / spikes) * Math.PI * 2 + e.animPhase * 0.5;
        ctx.lineTo(e.x + Math.cos(angle) * outerR, e.y + Math.sin(angle) * outerR);
        ctx.lineTo(e.x + Math.cos(nextAngle) * innerR, e.y + Math.sin(nextAngle) * innerR);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 2;
      ctx.stroke();
      break;
      
    case 'cautious':
      // Inimigo com olhos grandes (cauteloso)
      ctx.fillStyle = displayColor;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.45)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Olhos grandes e nervosos
      const eyeSize = e.radius * 0.25;
      const eyeOffset = e.radius * 0.4;
      const nervousness = Math.sin(time * 8) * 0.1;
      
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(e.x - eyeOffset + nervousness, e.y - eyeOffset, eyeSize, 0, Math.PI*2);
      ctx.arc(e.x + eyeOffset - nervousness, e.y - eyeOffset, eyeSize, 0, Math.PI*2);
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(e.x - eyeOffset + nervousness, e.y - eyeOffset, eyeSize*0.6, 0, Math.PI*2);
      ctx.arc(e.x + eyeOffset - nervousness, e.y - eyeOffset, eyeSize*0.6, 0, Math.PI*2);
      ctx.fill();
      break;
      
    case 'speedy':
      // Inimigo com rastros de movimento
      const trailLength = 5;
      for(let i = 0; i < trailLength; i++) {
        const alpha = 1 - (i / trailLength);
        const trailRadius = e.radius * (1 - i * 0.1);
        const trailX = e.x - (e.vx || 0) * i * 3;
        const trailY = e.y - (e.vy || 0) * i * 3;
        
        ctx.globalAlpha = alpha * 0.7;
        ctx.fillStyle = displayColor;
        ctx.beginPath();
        ctx.arc(trailX, trailY, trailRadius, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      
      // Corpo principal menor
      ctx.fillStyle = displayColor;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius * 0.8, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 2;
      ctx.stroke();
      break;
      
    case 'tank':
      // Inimigo grande e robusto
      const segments = 3;
      for(let i = 0; i < segments; i++) {
        const segmentRadius = e.radius * (1 - i * 0.15);
        const alpha = 1 - i * 0.2;
        
        ctx.globalAlpha = alpha;
        ctx.fillStyle = displayColor;
        ctx.beginPath();
        ctx.arc(e.x, e.y, segmentRadius, 0, Math.PI*2);
        ctx.fill();
        
        if(i === 0) {
          ctx.strokeStyle = 'rgba(100,100,100,0.8)';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      }
      ctx.globalAlpha = 1;
      break;
      
    case 'hunter':
      // Inimigo focado com mira
      ctx.fillStyle = displayColor;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.45)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Mira/crosshair quando ca√ßando
      if(e.behavior === 'chase' || e.behavior === 'hunt_food') {
        ctx.strokeStyle = '#00FF00';
        ctx.lineWidth = 2;
        const crossSize = e.radius * 1.2;
        
        ctx.beginPath();
        ctx.moveTo(e.x - crossSize, e.y);
        ctx.lineTo(e.x + crossSize, e.y);
        ctx.moveTo(e.x, e.y - crossSize);
        ctx.lineTo(e.x, e.y + crossSize);
        ctx.stroke();
        
        // C√≠rculo da mira
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius * 1.3, 0, Math.PI*2);
        ctx.stroke();
      }
      break;
  }
  
  // Indicador visual do medo (tremor) para todos os tipos
  if(e.fearLevel > 3){
    const shake = (Math.random()-0.5) * e.fearLevel;
    ctx.fillStyle = 'rgba(255,255,0,0.3)';
    ctx.beginPath();
    ctx.arc(e.x + shake, e.y + shake, e.radius * 1.1, 0, Math.PI*2);
    ctx.fill();
  }
}

function loop(){
  if(!gameRunning) return;
  update(); render(); requestAnimationFrame(loop);
}

function update(){
  movePlayer(); maybeMerge();

  // Atualizar Rage Mode
  const now = Date.now();
  if(player.rageMode && now > player.rageEnd) {
    player.rageMode = false;
  }

  // camera
  const cx = player.split? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
  const cy = player.split? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
  const mass = player.split? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass;
  const targetZoom = Math.max(0.45, Math.min(1.2, 1-(mass-10)/350));
  camera.zoom += (targetZoom-camera.zoom)*0.03; camera.x += (cx-camera.x)*0.08; camera.y += (cy-camera.y)*0.08;

  // atualizar part√≠culas
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.95; p.vy *= 0.95;
    if(Date.now() > p.life){
      particles.splice(i,1);
    }
  }

  // atualizar pellets ejetados
  for(let i=pellets.length-1;i>=0;i--){
    const p=pellets[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.98; p.vy *= 0.98;
    
    if(Date.now() > p.life){
      pellets.splice(i,1);
      continue;
    }
    
    if(p.x < 0 || p.x > WORLD_W || p.y < 0 || p.y > WORLD_H){
      pellets.splice(i,1);
      continue;
    }
  }

  // comer b√¥nus Rage
  for(let i=powerUps.length-1;i>=0;i--){
    const bonus=powerUps[i];
    const pX = player.split ? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
    const pY = player.split ? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
    const pRadius = player.split ? Math.max(player.splitBalls[0].radius,player.splitBalls[1].radius) : player.radius;
    
    if(Math.hypot(pX-bonus.x,pY-bonus.y) < pRadius+bonus.radius){
      // Ativar Rage Mode
      player.rageMode = true;
      player.rageEnd = now + 10000; // 10 segundos
      createParticles(bonus.x, bonus.y, '#FF006E');
      // Explos√£o de part√≠culas vermelhas
      for(let j=0; j<8; j++){
        createParticles(bonus.x + (Math.random()-0.5)*30, bonus.y + (Math.random()-0.5)*30, '#FF006E');
      }
      powerUps.splice(i,1);
      
      // Spawn novo b√¥nus ap√≥s um tempo
      setTimeout(()=>spawnRageBonus(), 3000 + Math.random()*5000);
    }
  }

  // comer frutas (com rage bonus)
  for(let i=food.length-1;i>=0;i--){
    const f=food[i];
    if(player.split){
      for(const b of player.splitBalls){
        if(Math.hypot(b.x-f.x,b.y-f.y)<b.radius+f.radius){ 
          createParticles(f.x, f.y, '#00FF88');
          const gain = 0.25*f.radius * (player.rageMode ? 3 : 1); // 3x no rage mode
          b.mass+=gain; b.radius=massToRadius(b.mass); score+=1; food.splice(i,1); 
          if(player.rageMode) createParticles(b.x, b.y, '#FF006E'); // Part√≠culas vermelhas extra
          break; 
        }
      }
    }else if(Math.hypot(player.x-f.x,player.y-f.y)<player.radius+f.radius){
      createParticles(f.x, f.y, '#00FF88');
      const gain = 0.25*f.radius * (player.rageMode ? 3 : 1); // 3x no rage mode
      player.mass+=gain; player.radius=massToRadius(player.mass); score+=1; food.splice(i,1);
      if(player.rageMode) createParticles(player.x, player.y, '#FF006E'); // Part√≠culas vermelhas extra
    }
  }

  // comer pellets (com rage bonus)
  for(let i=pellets.length-1;i>=0;i--){
    const p=pellets[i];
    if(player.split){
      for(const b of player.splitBalls){
        if(Math.hypot(b.x-p.x,b.y-p.y)<b.radius+p.radius){ 
          createParticles(p.x, p.y, '#FFD700');
          const gain = p.mass*0.8 * (player.rageMode ? 3 : 1); // 3x no rage mode
          b.mass+=gain; b.radius=massToRadius(b.mass); score+=1; pellets.splice(i,1); 
          if(player.rageMode) createParticles(b.x, b.y, '#FF006E');
          break; 
        }
      }
    }else if(Math.hypot(player.x-p.x,player.y-p.y)<player.radius+p.radius){
      createParticles(p.x, p.y, '#FFD700');
      const gain = p.mass*0.8 * (player.rageMode ? 3 : 1); // 3x no rage mode
      player.mass+=gain; player.radius=massToRadius(player.mass); score+=1; pellets.splice(i,1);
      if(player.rageMode) createParticles(player.x, player.y, '#FF006E');
    }
  }

  // inimigos com IA melhorada + colis√µes (com rage bonus)
  for(const e of enemies){
    // IA Inteligente
    updateEnemyAI(e, now);
    moveEnemyAI(e);
    
    // Aplicar movimento
    e.x += e.vx; 
    e.y += e.vy;
    
    // Manter dentro dos limites (com margem)
    e.x = Math.max(e.radius, Math.min(WORLD_W-e.radius, e.x)); 
    e.y = Math.max(e.radius, Math.min(WORLD_H-e.radius, e.y));
    
    // Inimigos comem frutas (mas s√≥ se n√£o est√£o fugindo)
    if(e.behavior !== 'flee'){
      for(let i=food.length-1;i>=0;i--){
        const f=food[i]; 
        if(Math.hypot(e.x-f.x,e.y-f.y)<e.radius+f.radius){ 
          e.mass+=0.2*f.radius; e.radius=massToRadius(e.mass); food.splice(i,1); 
        }
      }
    }
    
    for(let i=pellets.length-1;i>=0;i--){
      const p=pellets[i]; if(Math.hypot(e.x-p.x,e.y-p.y)<e.radius+p.radius){ e.mass+=p.mass*0.8; e.radius=massToRadius(e.mass); pellets.splice(i,1); }
    }
    
    const pMass = player.split ? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass;
    const pX = player.split ? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
    const pY = player.split ? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
    if(Math.hypot(pX-e.x,pY-e.y) < (player.split?Math.max(player.splitBalls[0].radius,player.splitBalls[1].radius):player.radius)+e.radius){
      if(pMass>e.mass*1.2){
        createParticles(e.x, e.y, '#FF4444');
        const g=e.mass*0.8 * (player.rageMode ? 2 : 1); // 2x no rage mode para inimigos
        if(player.split){ 
          player.splitBalls[0].mass+=g*0.5; player.splitBalls[1].mass+=g*0.5; 
          player.splitBalls[0].radius=massToRadius(player.splitBalls[0].mass); 
          player.splitBalls[1].radius=massToRadius(player.splitBalls[1].mass);
        } else { 
          player.mass+=g; player.radius=massToRadius(player.mass); 
        }
        if(player.rageMode){
          // Part√≠culas extra no rage mode
          for(let j=0; j<5; j++){
            createParticles(e.x + (Math.random()-0.5)*20, e.y + (Math.random()-0.5)*20, '#FF006E');
          }
        }
        
        // Respawn inimigo com nova IA
        e.mass=20+Math.random()*50; 
        e.radius=massToRadius(e.mass); 
        e.x=Math.random()*WORLD_W; 
        e.y=Math.random()*WORLD_H;
        e.behavior='wander';
        e.target=null;
        e.fearLevel=0;
        
      }else if(e.mass>pMass*1.1){ endGame(); }
    }
  }

  // HUD
  document.getElementById('score').textContent=score;
  document.getElementById('mass').textContent=Math.floor(player.split? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass);
  
  // Atualizar status do Rage Mode
  const rageStatusDiv = document.getElementById('rageStatus');
  if(player.rageMode && now < player.rageEnd){
    const remaining = Math.ceil((player.rageEnd - now) / 1000);
    document.getElementById('rageTime').textContent = remaining;
    rageStatusDiv.style.display = 'block';
  } else {
    rageStatusDiv.style.display = 'none';
  }
}

function render(){
  ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,W,H);

  // c√¢mera
  ctx.save();
  ctx.translate(W*0.5, H*0.5); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);

  // grid
  ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
  for(let x=0;x<WORLD_W;x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_H); ctx.stroke(); }
  for(let y=0;y<WORLD_H;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W,y); ctx.stroke(); }

  // frutas (emoji)
  for(const f of food){ ctx.font='18px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(f.emoji, f.x, f.y); }

  // b√¥nus Rage Mode
  for(const bonus of powerUps){
    const time = Date.now() * 0.005;
    const pulse = 1 + Math.sin(time + bonus.pulse) * 0.2;
    const pulseRadius = bonus.radius * pulse;
    
    // Glow effect vermelho
    ctx.shadowColor = bonus.color;
    ctx.shadowBlur = 15;
    
    // C√≠rculo do b√¥nus
    ctx.fillStyle = bonus.color;
    ctx.beginPath();
    ctx.arc(bonus.x, bonus.y, pulseRadius, 0, Math.PI*2);
    ctx.fill();
    
    // Emoji no centro
    ctx.shadowBlur = 0;
    ctx.font = '20px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(bonus.emoji, bonus.x, bonus.y);
  }

  // pellets ejetados
  for(const p of pellets){ 
    ctx.fillStyle='#FFD700'; 
    ctx.beginPath(); 
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); 
    ctx.fill(); 
    ctx.strokeStyle='rgba(255,255,255,0.6)'; 
    ctx.stroke(); 
  }

  // part√≠culas
  for(const p of particles){
    const life = Math.max(0, (p.life - Date.now()) / 800);
    if(life > 0){
      ctx.globalAlpha = life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0.1, p.size * life), 0, Math.PI*2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;

  // inimigos com tipos visuais diferentes
  for(const e of enemies){ 
    renderEnemy(e);
  }

  // player com pulsa√ß√£o e rage mode
  const time = Date.now() * 0.002;
  let pulse = 1 + Math.sin(time) * 0.03;
  
  // Rage Mode: pulsa√ß√£o mais intensa
  if(player.rageMode){
    pulse = 1 + Math.sin(time * 3) * 0.08; // 3x mais r√°pido e mais intenso
  }
  
  // Cores baseadas no rage mode
  let centerColor = '#66B2FF', midColor = '#4A90E2', borderColor = '#2E5C8A', strokeColor = '#1A4B73';
  let glowColor = null, glowBlur = 0;
  
  if(player.rageMode){
    centerColor = '#FF8FA3'; midColor = '#FF006E'; borderColor = '#CC0052'; strokeColor = '#990040';
    glowColor = '#FF006E'; glowBlur = 20;
  }
  
  if(player.split){
    for(const b of player.splitBalls){ 
      const pulseRadius = b.radius * pulse;
      
      // Glow effect para rage mode
      if(glowColor){
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = glowBlur;
      }
      
      const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, pulseRadius);
      gradient.addColorStop(0, centerColor);
      gradient.addColorStop(0.7, midColor);
      gradient.addColorStop(1, borderColor);
      
      ctx.fillStyle = gradient;
      ctx.beginPath(); 
      ctx.arc(b.x,b.y,pulseRadius,0,Math.PI*2); 
      ctx.fill(); 
      
      ctx.shadowBlur = 0;
      ctx.strokeStyle = strokeColor; 
      ctx.lineWidth = player.rageMode ? 3 : 2;
      ctx.stroke(); 
    }
  }else{
    const pulseRadius = player.radius * pulse;
    
    // Glow effect para rage mode
    if(glowColor){
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = glowBlur;
    }
    
    const gradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, pulseRadius);
    gradient.addColorStop(0, centerColor);
    gradient.addColorStop(0.7, midColor);
    gradient.addColorStop(1, borderColor);
    
    ctx.fillStyle = gradient;
    ctx.beginPath(); 
    ctx.arc(player.x,player.y,pulseRadius,0,Math.PI*2); 
    ctx.fill(); 
    
    ctx.shadowBlur = 0;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = player.rageMode ? 3 : 2;
    ctx.stroke();
  }

  ctx.restore();

  drawMini();
}

function drawMini(){
  if(minimapWrap.classList.contains('hidden')) return;
  const w=mini.width,h=mini.height; mctx.clearRect(0,0,w,h);
  mctx.fillStyle='#071c2d'; mctx.fillRect(0,0,w,h);
  const sx=w/WORLD_W, sy=h/WORLD_H;

  const halfW=(W*0.5)/camera.zoom, halfH=(H*0.5)/camera.zoom;
  mctx.strokeStyle='#ffffffb0'; mctx.lineWidth=1.5;
  mctx.strokeRect((camera.x-halfW)*sx,(camera.y-halfH)*sy,(halfW*2)*sx,(halfH*2)*sy);

  function dot(x,y,r,c){ mctx.fillStyle=c; mctx.beginPath(); mctx.arc(x*sx,y*sy,Math.max(2,r*sx*0.35),0,Math.PI*2); mctx.fill(); }
  for(const e of enemies) dot(e.x,e.y,e.radius,'#ff5577');
  for(const bonus of powerUps) dot(bonus.x,bonus.y,bonus.radius,'#FF006E'); // B√¥nus rage no minimap
  const px = player.split? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
  const py = player.split? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
  const pr = player.split? Math.max(player.splitBalls[0].radius,player.splitBalls[1].radius) : player.radius;
  dot(px,py,pr,'#00ff99');
}
</script>

</body>
</html>