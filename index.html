<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Agar Mobile (fix)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Arial,sans-serif}
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    #gameContainer{position:relative;width:100vw;height:100vh;background:linear-gradient(45deg,#001122 0%,#003344 100%)}
    #gameCanvas{display:block;width:100%;height:100%;touch-action:none;cursor:none}
    .hidden{display:none!important}
    /* HUD */
    #ui{position:absolute;left:10px;top:10px;z-index:10;color:#fff;text-shadow:0 2px 8px rgba(0,0,0,.8);background:rgba(0,0,0,.4);padding:6px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.15);font-weight:600}
    /* Start */
    #start{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20}
    #start .box{width:min(420px,92vw);background:rgba(0,0,0,.82);border:2px solid #00ff99;color:#fff;border-radius:14px;padding:18px;text-align:center;box-shadow:0 10px 26px rgba(0,0,0,.6)}
    #start h1{margin:6px 0 8px 0}
    #start button{width:100%;padding:16px;border-radius:12px;border:none;background:#00ff88;font-weight:800;font-size:18px}
    /* Game over */
    #over{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20}
    #over .box{width:min(420px,92vw);background:rgba(0,0,0,.9);border:2px solid #ff6666;color:#fff;border-radius:14px;padding:16px;text-align:center}
    #over button{padding:12px 18px;border-radius:10px;border:none;background:#00ff88;font-weight:800}
    /* Mobile buttons */
    #controls{position:absolute;right:10px;bottom:10px;z-index:12;display:flex;gap:8px}
    #controls button{border:none;border-radius:12px;padding:12px 14px;font-weight:800;background:#00bcd4}
    #controls button:nth-child(2){background:#ff8a65}
    #controls button:nth-child(3){background:#ffd54f;color:#000}
    /* Minimap (aparece s√≥ durante jogo) */
    #minimapWrap{position:absolute;right:10px;top:10px;z-index:12;background:rgba(0,0,0,.55);border:1px solid rgba(0,255,170,.6);border-radius:10px;padding:6px}
    #minimap{display:block;width:180px;height:130px;border-radius:6px}
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui" class="hidden">Pontua√ß√£o: <b id="score">0</b> ‚Ä¢ Massa: <b id="mass">10</b></div>
    <div id="start">
      <div class="box">
        <h1>ü¶† Agar Mobile</h1>
        <p>Toque para andar ‚Ä¢ Duplo-toque/Barra de espa√ßo: dividir ‚Ä¢ R: reunir</p>
        <button id="btnStart">COME√áAR</button>
      </div>
    </div>
    <div id="over" class="hidden">
      <div class="box">
        <h2>üíÄ Game Over</h2>
        <p>Pontua√ß√£o: <b id="finalScore">0</b> ‚Ä¢ Massa: <b id="finalMass">0</b></p>
        <button id="btnRestart">Jogar novamente</button>
      </div>
    </div>
    <div id="controls" class="hidden">
      <button id="btnSplit">Dividir</button>
      <button id="btnMerge">Reunir</button>
      <button id="btnEject">Ejetar</button>
    </div>
    <div id="minimapWrap" class="hidden"><canvas id="minimap" width="180" height="130"></canvas></div>
  </div>

<script>
// ===== Evita rolagem no iOS/Android durante o jogo =====
document.addEventListener('touchmove', (e)=>{ if (window.__GAME_RUNNING__) e.preventDefault(); }, {passive:false});

// ===== Setup b√°sico =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');
const ui = document.getElementById('ui');
const startPane = document.getElementById('start');
const overPane = document.getElementById('over');
const controls = document.getElementById('controls');
const minimapWrap = document.getElementById('minimapWrap');

let W = innerWidth, H = innerHeight, DPR = Math.max(1, Math.floor(devicePixelRatio||1));
function fit(){ W = innerWidth; H = innerHeight; DPR=Math.max(1,Math.floor(devicePixelRatio||1)); canvas.width=W*DPR; canvas.height=H*DPR; ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize', fit, {passive:true}); fit();

// ===== Mundo =====
const WORLD_W = 2400, WORLD_H = 1800;
const FRUITS = ['üçé','üçå','üçá','üçì','üçä'];
let gameRunning=false, score=0;
let player, enemies=[], food=[], powerUps=[], viruses=[], pellets=[];
let camera={x:WORLD_W/2,y:WORLD_H/2,zoom:1};
let mouse={x:WORLD_W/2,y:WORLD_H/2};
let moveTarget=null, startTime=0, splitEnd=0;
const INITIAL_MASS=12;

function massToRadius(m){ return Math.sqrt(Math.max(0.0001,m))*2+5; }

function reset(){
  player={x:WORLD_W/2,y:WORLD_H/2,mass:INITIAL_MASS,radius:massToRadius(INITIAL_MASS),vx:0,vy:0,split:false,splitBalls:[],magnet:false,shielded:false,speedBoost:false,multiGain:false};
  enemies=[]; food=[]; powerUps=[]; viruses=[]; pellets=[];
  for(let i=0;i<320;i++){food.push(randFruit());}
  for(let i=0;i<12;i++){spawnEnemy();}
  for(let i=0;i<12;i++){viruses.push({x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,radius:18+Math.random()*8,rotation:0,pulse:Math.random()*6.28});}
}
function randFruit(){ const e=FRUITS[Math.floor(Math.random()*FRUITS.length)]; return {x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,radius:10,emoji:e}; }
function spawnEnemy(){ const m=20+Math.random()*50; enemies.push({x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,mass:m,radius:massToRadius(m),vx:Math.random()-0.5,vy:Math.random()-0.5,color:'hsl('+(Math.random()*60+300)+',70%,55%)'}); }

// ===== Controles =====
document.getElementById('btnStart').onclick = startGame;
document.getElementById('btnRestart').onclick = startGame;
document.getElementById('btnSplit').onclick = ()=> splitPlayer();
document.getElementById('btnMerge').onclick = ()=> forceMerge();
document.getElementById('btnEject').onclick = ()=> ejectMass();

canvas.addEventListener('mousemove', (e)=>{ if(!gameRunning) return; const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(W/r.width); const y=(e.clientY-r.top)*(H/r.height); const cx=W*0.5, cy=H*0.5; mouse.x=((x-cx)/camera.zoom)+camera.x; mouse.y=((y-cy)/camera.zoom)+camera.y; moveTarget=null; });
let lastTap=0;
canvas.addEventListener('touchstart', (e)=>{
  if(!gameRunning) return;
  const now=Date.now();
  if(now-lastTap<250){ splitPlayer(); }
  lastTap=now;
  const t=e.touches[0]; const r=canvas.getBoundingClientRect();
  const x=(t.clientX-r.left)*(W/r.width); const y=(t.clientY-r.top)*(H/r.height);
  const cx=W*0.5, cy=H*0.5; const wx=((x-cx)/camera.zoom)+camera.x, wy=((y-cy)/camera.zoom)+camera.y;
  moveTarget={x:wx,y:wy};
},{passive:false});
canvas.addEventListener('touchmove', (e)=>{
  if(!gameRunning) return;
  const t=e.touches[0]; const r=canvas.getBoundingClientRect();
  const x=(t.clientX-r.left)*(W/r.width); const y=(t.clientY-r.top)*(H/r.height);
  const cx=W*0.5, cy=H*0.5; const wx=((x-cx)/camera.zoom)+camera.x, wy=((y-cy)/camera.zoom)+camera.y;
  moveTarget={x:wx,y:wy};
},{passive:false});

document.addEventListener('keydown',(e)=>{
  if(!gameRunning) return;
  if(e.key===' '){ e.preventDefault(); splitPlayer(); }
  if(e.key.toLowerCase()==='r'){ e.preventDefault(); forceMerge(); }
});

// ===== Jogo =====
function startGame(){
  reset();
  gameRunning=true; window.__GAME_RUNNING__=true;
  startTime=Date.now(); score=0; splitEnd=0; moveTarget=null;
  startPane.classList.add('hidden'); overPane.classList.add('hidden');
  ui.classList.remove('hidden'); controls.classList.remove('hidden'); minimapWrap.classList.remove('hidden');
  requestAnimationFrame(loop);
}
function endGame(){
  gameRunning=false; window.__GAME_RUNNING__=false;
  ui.classList.add('hidden'); controls.classList.add('hidden'); minimapWrap.classList.add('hidden');
  document.getElementById('finalScore').textContent=score;
  document.getElementById('finalMass').textContent=Math.floor(player.mass);
  overPane.classList.remove('hidden');
}

function speedFromRadius(r){ return (player.speedBoost?1.2:1.0)*(6/Math.sqrt(r+40)); }
function getTarget(){ return moveTarget?{x:moveTarget.x,y:moveTarget.y}:{x:mouse.x,y:mouse.y}; }

function movePlayer(){
  const t=getTarget();
  if(player.split && player.splitBalls.length){
    for(const b of player.splitBalls){
      const dx=t.x-b.x, dy=t.y-b.y, d=Math.hypot(dx,dy)||1;
      const ax=(dx/d)*0.35, ay=(dy/d)*0.35, maxS=speedFromRadius(b.radius);
      b.vx=(b.vx||0)*0.9+ax; b.vy=(b.vy||0)*0.9+ay;
      const v=Math.hypot(b.vx,b.vy); if(v>maxS){ b.vx=(b.vx/v)*maxS; b.vy=(b.vy/v)*maxS; }
      b.x+=b.vx; b.y+=b.vy; b.x=Math.max(b.radius,Math.min(WORLD_W-b.radius,b.x)); b.y=Math.max(b.radius,Math.min(WORLD_H-b.radius,b.y));
    }
  }else{
    const dx=t.x-player.x, dy=t.y-player.y, d=Math.hypot(dx,dy)||1;
    const ax=(dx/d)*0.35, ay=(dy/d)*0.35, maxS=speedFromRadius(player.radius);
    player.vx=(player.vx||0)*0.9+ax; player.vy=(player.vy||0)*0.9+ay;
    const v=Math.hypot(player.vx,player.vy); if(v>maxS){ player.vx=(player.vx/v)*maxS; player.vy=(player.vy/v)*maxS; }
    player.x+=player.vx; player.y+=player.vy; player.x=Math.max(player.radius,Math.min(WORLD_W-player.radius,player.x)); player.y=Math.max(player.radius,Math.min(WORLD_H-player.radius,player.y));
  }
}
function splitPlayer(){
  if(player.split || player.mass<20) return;
  const t=getTarget(); const a=Math.atan2(t.y-player.y,t.x-player.x), d=30, m=player.mass/2;
  player.split=true;
  player.splitBalls=[
    {x:player.x+Math.cos(a)*d,y:player.y+Math.sin(a)*d,mass:m,radius:massToRadius(m),vx:Math.cos(a)*3,vy:Math.sin(a)*3},
    {x:player.x-Math.cos(a)*d,y:player.y-Math.sin(a)*d,mass:m,radius:massToRadius(m),vx:-Math.cos(a)*3,vy:-Math.sin(a)*3}
  ];
  splitEnd = Date.now()+12000;
}
function forceMerge(){
  if(!player.split) return;
  const a=player.splitBalls[0], b=player.splitBalls[1]; const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2; const total=a.mass+b.mass;
  player.split=false; player.x=cx; player.y=cy; player.mass=total; player.radius=massToRadius(total); player.splitBalls=[]; player.vx=0; player.vy=0;
}
function maybeMerge(){
  if(!player.split) return;
  if(Date.now()>=splitEnd){
    const a=player.splitBalls[0], b=player.splitBalls[1];
    if(Math.hypot(a.x-b.x,a.y-b.y) < (a.radius+b.radius)*0.9) forceMerge();
  }
}

function loop(){
  if(!gameRunning) return;
  update(); render(); requestAnimationFrame(loop);
}

function update(){
  movePlayer(); maybeMerge();

  // camera
  const cx = player.split? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
  const cy = player.split? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
  const mass = player.split? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass;
  const targetZoom = Math.max(0.45, Math.min(1.2, 1-(mass-10)/350));
  camera.zoom += (targetZoom-camera.zoom)*0.03; camera.x += (cx-camera.x)*0.08; camera.y += (cy-camera.y)*0.08;

  // comer frutas
  for(let i=food.length-1;i>=0;i--){
    const f=food[i];
    if(player.split){
      for(const b of player.splitBalls){
        if(Math.hypot(b.x-f.x,b.y-f.y)<b.radius+f.radius){ b.mass+=0.25*f.radius; b.radius=massToRadius(b.mass); score+=1; food.splice(i,1); break; }
      }
    }else if(Math.hypot(player.x-f.x,player.y-f.y)<player.radius+f.radius){
      player.mass+=0.25*f.radius; player.radius=massToRadius(player.mass); score+=1; food.splice(i,1);
    }
  }

  // inimigos simples + colis√µes
  for(const e of enemies){
    e.x+=e.vx; e.y+=e.vy;
    if(e.x<e.radius||e.x>WORLD_W-e.radius) e.vx*=-1;
    if(e.y<e.radius||e.y>WORLD_H-e.radius) e.vy*=-1;
    // come fruta
    for(let i=food.length-1;i>=0;i--){
      const f=food[i]; if(Math.hypot(e.x-f.x,e.y-f.y)<e.radius+f.radius){ e.mass+=0.2*f.radius; e.radius=massToRadius(e.mass); food.splice(i,1); }
    }
    // player vs enemy
    const pMass = player.split ? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass;
    const pX = player.split ? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
    const pY = player.split ? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
    if(Math.hypot(pX-e.x,pY-e.y) < (player.split?Math.max(player.splitBalls[0].radius,player.splitBalls[1].radius):player.radius)+e.radius){
      if(pMass>e.mass*1.2){ // player come
        const g=e.mass*0.8; if(player.split){ player.splitBalls[0].mass+=g*0.5; player.splitBalls[1].mass+=g*0.5; player.splitBalls[0].radius=massToRadius(player.splitBalls[0].mass); player.splitBalls[1].radius=massToRadius(player.splitBalls[1].mass);} else { player.mass+=g; player.radius=massToRadius(player.mass); }
        // respawn inimigo
        e.mass=20+Math.random()*50; e.radius=massToRadius(e.mass); e.x=Math.random()*WORLD_W; e.y=Math.random()*WORLD_H;
      }else if(e.mass>pMass*1.1){ endGame(); }
    }
  }

  // HUD
  document.getElementById('score').textContent=score;
  document.getElementById('mass').textContent=Math.floor(player.split? player.splitBalls[0].mass+player.splitBalls[1].mass : player.mass);
}

function render(){
  ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,W,H);

  // c√¢mera
  ctx.save();
  ctx.translate(W*0.5, H*0.5); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);

  // grid
  ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
  for(let x=0;x<WORLD_W;x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_H); ctx.stroke(); }
  for(let y=0;y<WORLD_H;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_W,y); ctx.stroke(); }

  // frutas (emoji)
  for(const f of food){ ctx.font='18px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(f.emoji, f.x, f.y); }

  // inimigos
  for(const e of enemies){ ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.45)'; ctx.stroke(); }

  // player
  if(player.split){
    for(const b of player.splitBalls){ ctx.fillStyle='#4A90E2'; ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#2E5C8A'; ctx.stroke(); }
  }else{
    ctx.fillStyle='#4A90E2'; ctx.beginPath(); ctx.arc(player.x,player.y,player.radius,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#2E5C8A'; ctx.stroke();
  }

  ctx.restore();

  drawMini();
}

function drawMini(){
  if(minimapWrap.classList.contains('hidden')) return;
  const w=mini.width,h=mini.height; mctx.clearRect(0,0,w,h);
  mctx.fillStyle='#071c2d'; mctx.fillRect(0,0,w,h);
  const sx=w/WORLD_W, sy=h/WORLD_H;

  // viewport
  const halfW=(W*0.5)/camera.zoom, halfH=(H*0.5)/camera.zoom;
  mctx.strokeStyle='#ffffffb0'; mctx.lineWidth=1.5;
  mctx.strokeRect((camera.x-halfW)*sx,(camera.y-halfH)*sy,(halfW*2)*sx,(halfH*2)*sy);

  // dots
  function dot(x,y,r,c){ mctx.fillStyle=c; mctx.beginPath(); mctx.arc(x*sx,y*sy,Math.max(2,r*sx*0.35),0,Math.PI*2); mctx.fill(); }
  for(const e of enemies) dot(e.x,e.y,e.radius,'#ff5577');
  const px = player.split? (player.splitBalls[0].x+player.splitBalls[1].x)/2 : player.x;
  const py = player.split? (player.splitBalls[0].y+player.splitBalls[1].y)/2 : player.y;
  const pr = player.split? Math.max(player.splitBalls[0].radius,player.splitBalls[1].radius) : player.radius;
  dot(px,py,pr,'#00ff99');
}

// Inicia parado na tela de start (nada √© desenhado do mundo at√© startGame)
</script>
</body>
</html>
